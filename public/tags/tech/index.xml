<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on Kotet&#39;s Personal Blog</title>
    <link>https://kotet.jp/tags/tech/</link>
    <description>Recent content in Tech on Kotet&#39;s Personal Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 31 Dec 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://kotet.jp/tags/tech/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JekyllでテキストをHTML用にエスケープする</title>
      <link>https://kotet.jp/2016/12/2016-12-31-87e059092aed0a8aee9a/</link>
      <pubDate>Sat, 31 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/12/2016-12-31-87e059092aed0a8aee9a/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
Twitter cardsを設定するためにこちらの記事を参考にテンプレートを書いた。
Jekyll で作成したサイトを Twitter Card に対応させる
しかしこのまま使うとHTMLでエスケープすべき文字もそのまま埋め込まれてしまうため、うまく動かない時がある。
&amp;lt;meta name=&amp;#34;twitter:title&amp;#34; content=&amp;#34;{{ page.title }}&amp;#34; /&amp;gt; 具体例 たとえばこちらの記事のように、タイトルにセミコロンが入っていたりするとおかしくなる。
Jekyllのtheme&amp;rdquo;minima&amp;rdquo;のハンバーガーメニューがiOSで動作しないバグ
| escape escapeフィルタをつければ大丈夫。
&amp;lt;meta name=&amp;#34;twitter:title&amp;#34; content=&amp;#34;{{ page.title | escape}}&amp;#34; /&amp;gt; でもちょっとタイトルが長すぎるかもしれない。</description>
    </item>
    
    <item>
      <title>文字列の長さを取得するときはlengthを使ってはいけない</title>
      <link>https://kotet.jp/2016/12/2016-12-23-b6f1630928af176147e4/</link>
      <pubDate>Fri, 23 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/12/2016-12-23-b6f1630928af176147e4/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
自分の進捗表示用パッケージprogressにPRが来た。
Bars: bug on narrow terminals when non-ascii fill character is used
どうやら文字列の長さを得るときはlengthではいけない時があるそうだ。
どういうことか import std.stdio; void main() { string ascii = &amp;#34;a&amp;#34;; string non_ascii = &amp;#34;あ&amp;#34;; writeln(ascii.length); writeln(non_ascii.length); }1 3 &amp;quot;a&amp;quot;も&amp;quot;あ&amp;quot;も1文字のはずだが、&amp;quot;あ&amp;quot;.lengthは3になってしまっている。
writeln(cast(void[]) ascii); writeln(cast(void[]) non_ascii);[97] [227, 129, 130] lengthは文字列のバイト数を返しているようだ。
std.range.primitives.walkLength std.range.primitives.walkLengthは、empty == trueになるまで何回popFront()ができるか実際に試してみて、それで得られた長さを返す。
import std.stdio; import std.range : walkLength; void main() { string ascii = &amp;#34;a&amp;#34;; string non_ascii = &amp;#34;あ&amp;#34;; writeln(ascii.walkLength); writeln(non_ascii.walkLength); }1 1 ちゃんと正しい文字数が得られている。</description>
    </item>
    
    <item>
      <title>GitHubのissueを悪用して画像をホストする</title>
      <link>https://kotet.jp/2016/12/2016-12-14-a2203a400136ba50b41e/</link>
      <pubDate>Wed, 14 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/12/2016-12-14-a2203a400136ba50b41e/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
知らなかったので投稿。
DashというDで書かれたゲームエンジンがあるのだが、そのreadmeの一番上にあるでっかいロゴの画像ファイルがどこにおいてあるのか気になった。
リポジトリ内には見当たらない……しかしURLがgithubusercontent.comなのでGitHubのどこかに上げているんだろう。
[![Dash Logo](https://cloud.githubusercontent.com/assets/512416/2726786/6618d624-c5c2-11e3-9049-23637e5a1739.png)](https://github.com/Circular-Studios/Dash/wiki) 調べたらこのような記事が出てきた。issueの画像アップロード機能を&amp;rdquo;abuse&amp;rdquo;するのがおすすめ、とある。
Using issues to host GitHub Pages screenshots
issueのコメントに画像を貼り付けるとその場でアップロードされコードが生成される。このとき実際にissueを投稿しなくても同じURLで画像は存在し続けているようだ。
試しにやってみた。
![fzil2ccg](https://cloud.githubusercontent.com/assets/8435623/21176246/3b5aa50a-c229-11e6-8d23-eed54044ede4.jpg) この画像が実際に投稿されたissueはどこにも存在しないが、ちゃんと画像はそのまま見える状態のはずである。とても便利。</description>
    </item>
    
    <item>
      <title>待ち時間をD言語くんで彩る - 進捗表示ライブラリを作った</title>
      <link>https://kotet.jp/2016/12/2016-12-14-a4a26bfcc71b9dc2d511/</link>
      <pubDate>Wed, 14 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/12/2016-12-14-a4a26bfcc71b9dc2d511/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
かのマハトマ・ガンジーも &amp;gt; もし、私にD言語くんがなければ、これほど長く苦しい戦いには耐えられなかったでしょう。
と言ったように、生活の中でD言語くんを忘れないようにすることはとても大切です。退屈な待ち時間でもそこにD言語くんがいれば幸せになれるのではないでしょうか。 そこでPythonのprogressを参考にライブラリprogressを作りました。dubに登録してあります。
つかいかた 九九を教えてくれるD言語くん import progress.dman; import core.thread : Thread,dur; import std.string : format; void main() { auto dman = new DmanSpinner; foreach(i;0 .. 9*9) { dman.message = { auto left = (i/9)+1; auto right = (i%9)+1; return &amp;#34;%s * %s = %s&amp;#34;.format(left,right,left*right); }; dman.next(); Thread.sleep(dur!(&amp;#34;msecs&amp;#34;)(500)); } dman.finish(); } これであなたのプログラムにもD言語くん要素を入れることができます!
それではよいD言語くんライフを!</description>
    </item>
    
    <item>
      <title>サッと一時ブランチを作って作業して捨てる</title>
      <link>https://kotet.jp/2016/12/2016-12-07-d84f1638de9d50129faa/</link>
      <pubDate>Wed, 07 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/12/2016-12-07-d84f1638de9d50129faa/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
なにかちょこっとだけ作業するたびにトピックブランチをつくって終わったら消すということをしている。
 git branch &amp;lt;branch-name&amp;gt; [&amp;lt;start-point&amp;gt;] git checkout &amp;lt;branch-name&amp;gt; 作業 add &amp;amp; commit &amp;amp; push git checkout &amp;lt;some-branch&amp;gt; git branch -D &amp;lt;branch-name&amp;gt;  めんどくさくなってきたので専用コマンドを作った。こういうものを書くのは初めてなのでこちらの記事のものを書き換えて作った。
.bashrc tmpbranch() { ( d=$(mktemp -d &amp;#34;${TMPDIR:-/tmp}/${1:-$2}.XXXXXXXXXX&amp;#34;) &amp;amp;&amp;amp; git worktree add $d $1 -b $2 &amp;amp;&amp;amp; pushd &amp;#34;$d&amp;#34; || exit 1 &amp;#34;$SHELL&amp;#34; s=$? if [[ $s == 0 ]]; then rm -rf &amp;#34;$d&amp;#34; popd git worktree prune git branch -D $2 else echo &amp;#34;Directory &amp;#39;$d&amp;#39; still exists.</description>
    </item>
    
    <item>
      <title>改行とかのある文字列をエスケープしないで書きたい</title>
      <link>https://kotet.jp/2016/12/2016-12-06-170d11cc6b82592a8404/</link>
      <pubDate>Tue, 06 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/12/2016-12-06-170d11cc6b82592a8404/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
AAなどの文字列はエスケープすると超絶見難くなるのでそのまま書きたくなった。
エスケープされ見るも無残な姿になってしまったD言語くん1 string dman = &amp;#34; ____\n L__L|\n / \\\n / \\\n / _______ \\\n \\ \\#/ \\/ \\ /\n \\|#| O| O|#\\\n |#L _L__ #|\n |###| |##|\n /###/ /##|\n /###/ /##|\n /###/___/###/\n /###########/\n /##########/\n / \\\n \\ /\n _ \\ /__\n |__/ |__/&amp;#34;; Delimited Stringsというものがある。2デリミタ、文字列の終了を表す記号のある文字列である。それを使って以下のように書ける。
string s = q&amp;#34;/123&amp;#34;\n\n&amp;#34;/&amp;#34;;//string dman = &amp;#34;123\&amp;#34;\\n\\n\&amp;#34;&amp;#34;; writeln(s); このように出力される 123&amp;#34;\n\n&amp;#34; 通常エスケープしなければならない&amp;quot;がそのまま出力され、改行を表すはずの\nがそのまま出力されている。うれしい。この場合/がデリミタとなって、それに囲まれた部分で自由に書ける。ただしデリミタである/は書けない。
string s = q&amp;#34;/a/a/&amp;#34;;//エラーになる ただしNesting Delimiterという特殊なデリミタもある。
string s1 = q&amp;#34;((a)())&amp;#34;;//(a)() string s2 = q&amp;#34;(a(a)&amp;#34;;//これはだめ たくさんのカッコで囲まれた文字列とかを書くときに必要かもしれない。</description>
    </item>
    
    <item>
      <title>Jekyllのtheme&#34;minima&#34;のハンバーガーメニューがiOSで動作しないバグ</title>
      <link>https://kotet.jp/2016/11/2016-11-29-hamburger-menu-not-working/</link>
      <pubDate>Tue, 29 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/11/2016-11-29-hamburger-menu-not-working/</guid>
      <description>現在このブログのハンバーガーメニューはうまく機能していない。
今日はこの問題を解決しようと思って調べた。どうやら自分がなにかやらかしていたわけではなく、このブログのthemeであるminimaのバグのようだ。
Hamburger menu doesn&amp;rsquo;t work on iOS · Issue #80 · jekyll/minima
すでにPRが送られているが、マージされてはいない。
fix hamburger menu for iOs by melaniewalsh · Pull Request #85 · jekyll/minima
とりあえず修正できないか頑張る。
PRの内容通り8行目のspanにダミーハンドラonclick=&amp;quot;void(0)&amp;quot;を追加してみる。これによってiOSのブラウザはその要素をクリック可能なものとして認識するようだ。
- &amp;lt;span class=&amp;#34;menu-icon&amp;#34;&amp;gt; + &amp;lt;span class=&amp;#34;menu-icon&amp;#34; onclick=&amp;#34;void(0)&amp;#34;&amp;gt;  これで無事に動いた。めでたし。</description>
    </item>
    
    <item>
      <title>ローカルのdubプロジェクトに依存するdubプロジェクト</title>
      <link>https://kotet.jp/2016/11/2016-11-27-4ef5039d17c521ec5dc7/</link>
      <pubDate>Sun, 27 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/11/2016-11-27-4ef5039d17c521ec5dc7/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
自作のライブラリを別のdubプロジェクトにしたかったので調べたけどすぐには見つからなかったので書く。わかれば簡単なことだった。タイトルはこれで適切なんだろうか?
$ tree . ├── app │ ├── dub.json │ └── source │ └── app.d └── lib ├── dub.json └── source └── lib.d lib/source/lib.d:
module lib; import std.stdio; void func() { writeln(&amp;#34;hello!&amp;#34;); } app/source/app.d:
import lib; void main() { func();//モジュールlibの関数 } lib/dub.json:
{ &amp;#34;name&amp;#34;: &amp;#34;lib&amp;#34;, &amp;#34;targetType&amp;#34;:&amp;#34;library&amp;#34; } app/dub.json:
{ &amp;#34;name&amp;#34;: &amp;#34;app&amp;#34;, &amp;#34;dependencies&amp;#34;:{ &amp;#34;lib&amp;#34;: &amp;#34;*&amp;#34; } } このままではlibが見つからないので実行できない。
$ dub run Selected package lib ~master doesn&amp;#39;t exist. Using latest matching version instead.</description>
    </item>
    
    <item>
      <title>どどんとふ on windows</title>
      <link>https://kotet.jp/2016/11/2016-11-17-fca7f3550b554ee7cfd3/</link>
      <pubDate>Thu, 17 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/11/2016-11-17-fca7f3550b554ee7cfd3/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
主に友人に需要があるそうなのでWindows上でどどんとふサーバーを動かせるか頑張った。
XAMPPのインストール Apache httpdのWindows版は公式で配布していないらしい。XAMPPをインストールする。
Apache以外は入れなくていい。
Rubyのインストール こちらの記事を参照。インストール時に「PATHを設定する」にチェックする。
インストールに成功しているかコマンドプロンプトでruby -vしてみる。
どどんとふの設置 どどんとふをダウンロードしてくる。
public_html内のDodontoFとimageUploadSpaceをドキュメントルート内に展開。ファイルの改行コードを全部変換。 kanjitranslatorが便利だった。
一つ上にsaveDataを展開。
DodontoF/DodontoFServer.rbのshebangを編集。PATHを通してあるのでrubyとだけ書けばいい。
一行目 #!ruby Apacheを起動し、ブラウザでlocalhost/DodontoF/DodontoFServer.rbにアクセスしてみる。 すでにポートは解放されているので、ルータとかの設定をすればもう使える。 セキュリティは考えていない。Windowsでは何をすればセキュリティを考えたことになるのかまた調べておきたい。</description>
    </item>
    
    <item>
      <title>JSONValueにJSONValueを入れる</title>
      <link>https://kotet.jp/2016/10/2016-10-29-94ac71bb6d196dff6f47/</link>
      <pubDate>Sat, 29 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/10/2016-10-29-94ac71bb6d196dff6f47/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
語彙が足りなくて適切なタイトルが出てこない。
とにかくそういう事をするときは、JSONValue[string]という状態でないといけないようだ。
import std.json : JSONValue,toJSON; auto json = JSONValue([&amp;#34;Dman&amp;#34;:&amp;#34;&amp;#34;]); json[&amp;#34;Dman&amp;#34;].object = JSONValue([&amp;#34;is&amp;#34;:&amp;#34;GOD&amp;#34;]).object; //json[&amp;#34;dman&amp;#34;].object = JSONValue([&amp;#34;is&amp;#34;:&amp;#34;GOD&amp;#34;]); &amp;lt;-こうはできない assert(toJSON(&amp;amp;json) == `{&amp;#34;dman&amp;#34;:{&amp;#34;is&amp;#34;:&amp;#34;GOD&amp;#34;}}`); キーを後から追加したりすることはできないのかな?</description>
    </item>
    
    <item>
      <title>D言語でBasic認証</title>
      <link>https://kotet.jp/2016/10/2016-10-26-21bdd7902454434ab1ce/</link>
      <pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/10/2016-10-26-21bdd7902454434ab1ce/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
std.net.curlを使えば簡単にできた。探すのにすこし時間がかかったのでサンプル的なものを書く。
import std.stdio : writeln; import std.net.curl : HTTP,get; void main() { auto url = &amp;#34;URL&amp;#34;; auto user = &amp;#34;USER&amp;#34;; auto pass = &amp;#34;PASS&amp;#34;; auto http = HTTP(); http.authenticationMethod = HTTP.AuthMethod.basic; http.setAuthentication(user,pass); auto content = get(url,http); writeln(content); } HTTP.AuthMethodはetc.c.curl.CurlAuthのエイリアス。</description>
    </item>
    
    <item>
      <title>Dでつくるbrainfu*kのインタプリタ</title>
      <link>https://kotet.jp/2016/08/2016-08-12-0028bc07f5277fff4d8d/</link>
      <pubDate>Fri, 12 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/08/2016-08-12-0028bc07f5277fff4d8d/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
brainf*ckの処理系はすでにいろんな人が作っているけど勉強になりそうだったので自分で書いてみた。
import std.stdio; import std.getopt; import core.stdc.stdio; import std.file; import std.conv; const BUFFSIZE = 30000; void main(string[] args) { string filename = args[1]; string code = readText(filename); size_t ptr = 0; size_t codeptr = 0; ubyte[] memory = new ubyte[BUFFSIZE]; while(codeptr &amp;lt; code.length) { switch(code[codeptr]) { case &amp;#39;+&amp;#39;: memory[ptr]++; break; case &amp;#39;-&amp;#39;: memory[ptr]--; break; case &amp;#39;&amp;gt;&amp;#39;: ptr++; break; case &amp;#39;&amp;lt;&amp;#39;: ptr--; break; case &amp;#39;.&amp;#39;: putchar(memory[ptr]); break; case &amp;#39;,&amp;#39;: int tmp = getchar(); if(tmp == EOF) return; memory[ptr] = tmp.</description>
    </item>
    
    <item>
      <title>OpenGL/GLFWはじめての人がD言語でウィンドウを表示するまで</title>
      <link>https://kotet.jp/2016/06/2016-06-28-16583bad8631623e9bcc/</link>
      <pubDate>Tue, 28 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/06/2016-06-28-16583bad8631623e9bcc/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
DでOpenGLとかそういうのが使いたくなったので練習をした。
Dubを使って環境構築した記事がなかなか見つからなかったのでまとめ記事を書く。
Ubuntu 16.04 LTS。
OpenGLとGLFWの導入 OpenGL $sudo apt install mesa-utils GLFW $sudo apt install xorg-dev $git clone https://github.com/glfw/glfw.git $cd glfw ここで共有ライブラリを作るようにCMakeLists.txtを書き換える。
でないと実行時にこうなる。
エラー libglfw3.so - libglfw3.so: cannot open shared object file: No such file or directory libglfw.so.3 - libglfw.so.3: cannot open shared object file: No such file or directory CMakeLists.txt -option(BUILD_SHARED_LIBS &amp;#34;Build shared libraries&amp;#34; OFF) +option(BUILD_SHARED_LIBS &amp;#34;Build shared libraries&amp;#34; ON) $cmake . $make $sudo make install -- Installing: /usr/local/lib/libglfw.</description>
    </item>
    
    <item>
      <title>自分以外のユーザの作ったリストを取得する</title>
      <link>https://kotet.jp/2016/06/2016-06-03-a206127cf8e75cc7a719/</link>
      <pubDate>Fri, 03 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/06/2016-06-03-a206127cf8e75cc7a719/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
フォローイング/フォロワーの作ったリストのリストが欲しくなって、そういうものを作るツールを作った時のメモ。
はじめTweepyでやろうと思ったんだけど、自分以外の持っているリストを取得する、つまりlists/list、lists/ownerships、lists/subscriptionsなどに対応する機能が見つけられなかった。
結局自力でやることになった。なんで無いんだろう……
from requests_oauthlib import OAuth1Session import json session = OAuth1Session(consumer_key, consumer_secret, access_token, access_token_secret) api_url = &amp;#39;https://api.twitter.com/1.1/lists/ownerships.json&amp;#39; params = {&amp;#39;user_id&amp;#39;: userid} req = session.get(api_url, params=params) if req.status_code == 200: jsn = json.loads(req.text) for item in jsn[&amp;#39;lists&amp;#39;]: print(item[&amp;#39;name&amp;#39;]) else: print(&amp;#39;Error: %d&amp;#39; % req.</description>
    </item>
    
    <item>
      <title>行列と高速化の練習をした</title>
      <link>https://kotet.jp/2016/05/2016-05-12-c3b3c20f4257f83dce8c/</link>
      <pubDate>Thu, 12 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/05/2016-05-12-c3b3c20f4257f83dce8c/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
行列に興味がある。しかし数Cは廃止され、行列の勉強はしないとのことなので少しづつ自主学習。
とりあえず行列の積について理解できたのでプログラムにしてみる。ついでに前からやってみたかった並列処理とかを試して速度をはかる。
テンプレート 100次の正方行列を1000回かける。
//import略 alias int[][] matrix; matrix matrix_product(matrix A,matrix B) in{ assert(A[0].length == B.length); } body{ //ここに処理を書く } void init_matrix(ref matrix A){ foreach(ref row;A){ foreach(ref n;row){ n = uniform(-10,10); } } } void main(){ matrix A = [ [2,-1], [-3,4]]; matrix B = [ [1], [2]]; matrix C = [ [1,-1], [-2,3]]; matrix D = [ [1,2], [3,4]]; matrix E = [ [1,2]]; matrix F = [ [2,-1], [-3,4]]; assert(matrix_product(A,B) == [[0],[5]]); assert(matrix_product(C,D) == [[-2,-2],[7,8]]); assert(matrix_product(E,F) == [[-4,7]]); StopWatch sw; int n = 1000; matrix[][] testdata = new matrix[][](n,2); foreach(i;0.</description>
    </item>
    
    <item>
      <title>どどんとふ1.46.00を最小構成のCentOS7から構築できた時の手順</title>
      <link>https://kotet.jp/2016/03/2016-03-30-ec6701540ea336083405/</link>
      <pubDate>Wed, 30 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/03/2016-03-30-ec6701540ea336083405/</guid>
      <description>この記事はQiitaに投稿されたものの転載です。
こちらやこちらの手順にしたがってどどんとふのセットアップをしていたが、それだけでは動かなかったのでほんの少し追記したものを自分でもう一度まとめて書く。CentOS7をminimumな感じでインストールしたあとから始める。
必要なものどもを取得 $ sudo yum update $ sudo yum install wget libyaml-devel gcc httpd unzip policycoreutils-python rubyのセットアップ $ wget http://cache.ruby-lang.org/pub/ruby/2.1/ruby-2.1.6.tar.gz $ tar -zxvf ruby-2.1.6.tar.gz $ cd ruby-2.1.6 $ ./configure $ sudo make install どどんとふのセットアップ //どどんとふの取得&amp;amp;展開 $ cd ~ $ wget http://www.dodontof.com/Download/DodontoF_release/DodontoF_Ver.1.46.00_MASTERPIECE.zip $ unzip DodontoF_Ver.1.46.00_MASTERPIECE.zip $ sudo mv DodontoF_WebSet/* /var/www/ //所有権とかセキュリティコンテクストとか権限の変更 $ cd /var/www $ sudo chown -R apache:apache public_html/ saveData/ $ sudo chcon -R -t httpd_sys_content_t public_html/ saveData/ $ cd public_html/DodontoF $ sudo chmod -R 705 saveDataTempSpace fileUploadSpace replayDataUploadSpace .</description>
    </item>
    
    <item>
      <title>ズンドコキヨシ with D</title>
      <link>https://kotet.jp/2016/03/2016-03-13-9d170a372434caf0c876/</link>
      <pubDate>Sun, 13 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://kotet.jp/2016/03/2016-03-13-9d170a372434caf0c876/</guid>
      <description> この記事はQiitaに投稿されたものの転載です。
元ネタを読んで一番最初に思いついたやり方です。
main.d import std.stdio; import std.random; void main(){ string[] words = [&amp;#34;ズン&amp;#34;,&amp;#34;ドコ&amp;#34;]; int[] history = []; while(true){ history ~= dice(1,1); words[history[$-1]].write(); if (5 &amp;lt;= history.length) { if (history[$-5 .. $] == [0,0,0,0,1]){ &amp;#34;キ・ヨ・シ！&amp;#34;.writeln(); return; } } } }</description>
    </item>
    
  </channel>
</rss>