<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content=" ‪&#34;Dには、こんにち使用されている多くの言語と同じように、すぐに使えるガベージコレクタがあります。‬‪GCのことを心配せずにかけて、それを最大限活用できるタイプのソフトウェアが多くあります。‬しかしGCは不利な点を持ち、ガベージコレクションが望ましくないシナリオがたしかにあります。‬&#34; "><link rel=stylesheet href=https://blog.kotet.jp/sass/single.min.4766c569d312c6d675e91283a04d164a4e46fcd5e2f6daffd92725bf5007d3e8.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/d.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js></script>
<script>hljs.configure({languages:[]}),hljs.initHighlightingOnLoad()</script><script>document.addEventListener("DOMContentLoaded",function(){if(document.body.querySelector("math")||document.body.textContent.match(/(?:\$|\\\(|\\\[|\\begin\{.*?})/)){let t=document.createElement("script");t.type="text/x-mathjax-config",t[window.opera?"innerHTML":"text"]="MathJax.Hub.Config({\n  tex2jax: { inlineMath: [['$','$'], ['\\\\(','\\\\)']],\n  displayMath: [['$$','$$']],\n  processEscapes: true\n }\n});",document.head.appendChild(t);var e=document.createElement("script");e.async="async",e.src="//cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML",document.head.appendChild(e)}})</script><script>document.addEventListener("DOMContentLoaded",function(){let e=document.querySelectorAll(".footnote-ref");for(const t of e){let n=new URL(t.href),s=document.getElementById(n.hash.substr(1)),o=s.innerText.trim().replace("↩︎","");t.title=o}})</script><title>#dlang 死神を恐れないで - GCについて知る【翻訳】 - Kotet's Personal Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://blog.kotet.jp/2017/04/dont-fear-the-reaper/><link rel=icon href=/favicon.ico><link href=https://github.com/kotet rel=me><link rel=webmention href=https://webmention.io/blog.kotet.jp/webmention><meta name=twitter:card content="summary"><meta property="og:type" content="article"><meta property="og:site_name" content="Kotet's Personal Blog"><meta name=og:title content="#dlang 死神を恐れないで - GCについて知る【翻訳】 - Kotet's Personal Blog"><meta name=og:description content=" ‪&#34;Dには、こんにち使用されている多くの言語と同じように、すぐに使えるガベージコレクタがあります。‬‪GCのことを心配せずにかけて、それを最大限活用できるタイプのソフトウェアが多くあります。‬しかしGCは不利な点を持ち、ガベージコレクションが望ましくないシナリオがたしかにあります。‬&#34;  "><meta property="og:locale" content="ja_JP"><meta name=og:image content="https://blog.kotet.jp/img/common/logo.png"><meta name=twitter:url content="https://blog.kotet.jp/2017/04/dont-fear-the-reaper/"><meta name=twitter:site content="@kotetttt"><meta name=twitter:creator content="@kotetttt"><meta name=generator content="Hugo 0.119.0"><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script>
<script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-8443812672116269",enable_page_level_ads:!0})</script></head><body><header class=site><nav><ul><li><span class=text-bottom>HOME</span><a href=/ title=tag><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22" height="20" viewBox="0 0 22 20"><title>home</title><desc>Created with Sketch.</desc><defs/><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="home" transform="translate(-1.000000, -2.000000)"><rect id="placeholder" fill-opacity="0" fill="#fff" x="0" y="0" width="24" height="24"/><path d="M18.0013141 10 11.9999857 3.99867157 5.99865727 10H6V20H18V10H18.0013141zM20 11.9986859V20c0 1.1045695-.8954305 2-2 2H6c-1.1045695.0-2-.8954305-2-2V11.9986573L2.52318352 13.4754737 1.10998535 12.0622756 10.5869711 2.5852898c.780386400000001-.7803864 2.0456428-.7803864 2.8260292.0l9.4769857 9.4769858-1.4131981 1.4131981L20 11.9986859z" id="Combined-Shape" fill="#000" fill-rule="nonzero"/></g></g></svg></a></li><li><span class=text-up>ABOUT</span><a href=/about title=about><svg width="22" height="22" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><desc>Created with Sketch.</desc><defs/><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="info" transform="translate(-1.000000, -1.000000)"><rect id="placeholder" fill-opacity="0" fill="#fff" x="0" y="0" width="24" height="24"/><path d="M12 23C5.92486775 23 1 18.0751322 1 12 1 5.92486775 5.92486775 1 12 1c6.0751322.0 11 4.92486775 11 11 0 6.0751322-4.9248678 11-11 11zm0-2c4.9705627.0 9-4.0294373 9-9 0-4.97056275-4.0294373-9-9-9-4.97056275.0-9 4.02943725-9 9 0 4.9705627 4.02943725 9 9 9zm1.0036109-7.0016536h.9993435v2h-4v-2h1v-2h-1V9.99834639h3.0006565V13.9983464zM12.0003283 8.99834639c-.5524661.0-1.0003283-.44771525-1.0003283-1s.447862199999999-1 1.0003283-1c.552466000000001.0 1.0003282.44771525 1.0003282 1s-.447862199999999 1-1.0003282 1z" id="Oval-17" fill="#000" fill-rule="nonzero"/></g></g></svg></a></li><li><span class=text-bottom>DOWNLOAD</span><a href=/products title=download><svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><desc>Created with Sketch.</desc><defs/><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="download" transform="translate(-2.000000, -2.000000)"><rect id="placeholder" fill-opacity="0" fill="#fff" x="0" y="0" width="24" height="24"/><path d="M22 16v4c0 1.1045695-.8954305 2-2 2H4c-1.1045695.0-2-.8954305-2-2V16H4v4H20V16h2zm-9-3.4142136 3.2928932-3.29289318 1.4142136 1.41421358L12 16.4142136 6.29289322 10.7071068 7.70710678 9.29289322 11 12.5857864V2h2V12.5857864z" id="Combined-Shape" fill="#000"/></g></g></svg></a></li><li><span class=text-up>TAG</span><a href=/tags title=tag><svg width="22" height="14" viewBox="0 0 22 14" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><desc>Created with Sketch.</desc><defs/><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="tag" transform="translate(-1.000000, -5.000000)"><rect id="placeholder" fill-opacity="0" fill="#fff" x="0" y="0" width="24" height="24"/><path d="M6.53518376 5H21c1.1045695.0 2 .8954305 2 2V17c0 1.1045695-.8954305 2-2 2H6.53518376C5.86647738 19 5.24201473 18.6657977 4.87108317 18.1094004L1.16794971 12.5547002c-.223932945-.335899399999999-.223932945-.773501.0-1.1094004L4.87108317 5.89059961C5.24201473 5.33420227 5.86647738 5 6.53518376 5zM3.20185043 12l3.33333333 5H21V7H6.53518376L3.20185043 12zM7 13C6.44771525 13 6 12.5522847 6 12s.44771525-1 1-1S8 11.4477153 8 12s-.44771525 1-1 1z" id="Rectangle-29" fill="#000" fill-rule="nonzero"/></g></g></svg></a></li><li><span class=text-bottom>FEED</span><a href=/index.xml title=feed><svg width="22" height="18" viewBox="6 8 .5 10" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><desc>Created with Sketch.</desc><defs><path d="M1 21V19c1.1045695.0 2 .8954305 2 2H1zm6 0H5c0-2.209139-1.790861-4-4-4V15c3.3137085.0 6 2.6862915 6 6zm4 0H9c0-4.418278-3.581722-8-8-8V11c5.5228475.0 10 4.4771525 10 10z" id="path-1"/></defs><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="cast" transform="translate(-1.000000, -3.000000)"><rect id="placeholder" fill-opacity="0" fill="#fff" x="0" y="0" width="24" height="24"/><mask id="mask-2" fill="#fff"><use xlink:href="#path-1"/></mask><use id="Combined-Shape" fill="#000" fill-rule="nonzero" xlink:href="#path-1"/></g></g></svg></a></li></ul></nav><h1><a href=/>KOTET'S PERSONAL BLOG</a></h1></header><main><header><h2><span><a href=/tags/dlang>#dlang</a>
死神を恐れないで - GCについて知る【翻訳】</span></h2><p>Created: <time>2017-04-16</time>,
Last modified: <time>2018-09-07</time><br><a href=/tags/dlang>#dlang</a> <a href=/tags/tech>#tech</a> <a href=/tags/translation>#translation</a> <a href=/tags/dlang_gc_series>#dlang_gc_series</a> <a href=/tags/d_blog>#d_blog</a></p><div style="border:.5em solid gold;padding:1em;margin-bottom:1em"><p style=font-weight:700;margin:0>これは1年以上前の記事です</p><p style=margin:0>ここに書かれている情報、見解は現在のものとは異なっている場合があります。</p></div><aside><p>Table of Contents</p><nav id=TableOfContents></nav></aside></header><article><p>この記事は</p><p><a href=http://dlang.org/blog/2017/03/20/dont-fear-the-reaper/>Don’t Fear the Reaper – The D Blog</a></p><p>の翻訳である。
翻訳したものを公開する
<a href=http://dlang.org/blog/2017/03/20/dont-fear-the-reaper/#comment-1355>許可をもらえた</a>
ので、ここに公開する。
誤字や誤訳などを見つけたら今すぐ
<a href=https://github.com/kotet/blog.kotet.jp>Pull request</a>だ!</p><hr><p>Dには、こんにち使用されている多くの言語と同じように、すぐに使えるガベージコレクタがあります。
GCのことを心配せずにかけて、それを最大限活用できるタイプのソフトウェアが多くあります。
しかしGCは不利な点を持ち、ガベージコレクションが望ましくないシナリオがたしかにあります。
そのようなシチュエーションで、言語はそれを一時的に無効化したり、完全に回避する方法を提供します。</p><p>ガベージコレクションのポジティブな影響を最大化し、ネガティブな面を最小化するために、
DでGCがどのように動作するかの下地を持つことが必要です。
スタート地点として最適なのは
<a href=http://dlang.org/spec/garbage.html>dlang.orgのガベージコレクションのページ</a>
でしょう、DのGCの原理を概説し、それを使うためのヒントを提供します。
この投稿はそのページで提供されている情報を拡大するシリーズの最初にするつもりです。</p><p>今回は、非常に基本的なこと、GCアロケーションを引き起こす言語機能にフォーカスしていきます。
将来の投稿で必要な時にGCを無効化する方法や、非決定論的性質に対処するのに役立つイディオムを紹介します
(GCで管理されたオブジェクトのデストラクタのリソースの管理など)。</p><p>まず、Dのガベージコレクタについて理解することは、それがアロケーション中の、
アロケートに利用できるメモリがないときのみ動作するということです。
それは後ろで居座ったりせず、ちらほらヒープをスキャンしゴミ集めをしたりしません。
この知識はGC管理されたメモリを効率的に使うコードを書くことにおいての基本です。
下の例を見てみましょう:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-d data-lang=d><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>[]</span> <span class=n>ints</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span><span class=o>(</span><span class=n>i</span><span class=o>;</span> <span class=mf>0.</span><span class=o>.</span><span class=na>100</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ints</span> <span class=o>~=</span> <span class=n>i</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>これは<code>int</code>の動的配列を宣言し、
<a href=https://dlang.org/spec/statement.html#foreach-range-statement>foreachレンジループ</a>
内で0から99までの数字を追加するためにDの追加演算子を使っています。
素人目には追加演算子が配列に追加する値のスペースをアロケートするためにGCヒープを使用していることはわかりません。</p><p>DRuntimeの配列の実装は馬鹿ではありません。
この例の中では、それぞれの値でいちいち100回のアロケーションは行われません。
さらなるメモリが必要なとき、実装は要求されたのより多くのスペースをアロケートします。
この特殊なケースで、実際にどれくらいのアロケーションが行われたかをDの動的配列とスライスの
<a href=https://dlang.org/phobos/object.html#.capacity><code>capacity</code></a>プロパティを使って特定できます。
これはアロケーションが必要になる前に配列が持つことができる要素の合計値を返します。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-d data-lang=d><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>std.stdio</span> <span class=o>:</span> <span class=n>writefln</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>[]</span> <span class=n>ints</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=nb>size_t</span> <span class=n>before</span><span class=o>,</span> <span class=n>after</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span><span class=o>(</span><span class=n>i</span><span class=o>;</span> <span class=mf>0.</span><span class=o>.</span><span class=na>100</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>before</span> <span class=o>=</span> <span class=n>ints</span><span class=o>.</span><span class=na>capacity</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ints</span> <span class=o>~=</span> <span class=n>i</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>after</span> <span class=o>=</span> <span class=n>ints</span><span class=o>.</span><span class=na>capacity</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>before</span> <span class=o>!=</span> <span class=n>after</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>writefln</span><span class=o>(</span><span class=s>&#34;Before: %s After: %s&#34;</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                <span class=n>before</span><span class=o>,</span> <span class=n>after</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><strong>DMD 2.073.2</strong>でコンパイルしてこれを実行した時、メッセージは6回プリントされ、
これは合計6回のGCアロケーションがループの中であったことを意味します。
つまりGCがゴミを収集する機会が6回あったということです。
この小さな例では、それはほぼ確実に起こりません。
もしこのループがもっと大きなプログラムの一部だった場合、全体にGCのアロケーションがあれば、確実に起こるでしょう。</p><p>付け加えると、これは<code>事前</code>と<code>事後</code>の値を調べることの参考になります。
これを行うと0、3、7、15、31、63、127というシーケンスが見られます。
最終的に、<code>ints</code>には100の値が入り、次のアロケーションの前に27以上の追加できるスペースを持ち、
シーケンスの値から推定するに、255になるでしょう。
これはDRuntimeの実装の詳細ですが、リリースで微調整や変更され得ます。
配列やスライスがGCによってどのように管理されるかのさらなる詳細は、Steven Schveighofferの
このトピックに関する<a href=https://dlang.org/d-array-article.html>素晴らしいアーティクル</a>を見てください。</p><p>それで、6回のアロケーションは、単純で小さなループにおいてもGCがそれを予測不能な長さ休止させる6回の機会です。
一般的に、それはループがコードのホットパートかと、GCヒープから合計どれくらいのメモリが
アロケートされているかに依存する問題になりえます。
しかし、それは必ずしもコードのその部分でGCを無効化する理由にはなりません。</p><p>CやC++のような、独創的なストックGCのついていない言語と同じように、
出来る限り前方でアロケートすることによって全体のパフォーマンスをより良くしたり、
内側のループでのアロケーションを最小化することを多くのプログラマは学びます。
それは本当の諸悪の根源ではなく、<strong>ベストプラクティス</strong>と呼ばれる傾向のある時期尚早な最適化のタイプの1つです。
DのGCがメモリがアロケートされるときにのみ走ることを考えると、
パフォーマンスへの潜在的影響を軽減するシンプルな方法として同じ戦略が適用できます。
こちらは例を書き換えたひとつです:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-d data-lang=d><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>[]</span> <span class=n>ints</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[](</span><span class=mi>100</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span><span class=o>(</span><span class=n>i</span><span class=o>;</span> <span class=mf>0.</span><span class=o>.</span><span class=na>100</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ints</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>今や6つのアロケーションは1つになりました。
GCが実行される唯一の機会は内側のループの前です。
これは実際にループに入る前に少なくとも100の値のスペースをアロケートし、それらすべてを0で初期化します。
<code>new</code>のあと配列の長さは100になりますが、ほとんど確実に追加のキャパシティがあります。</p><p>配列の<code>new</code>する代わりの方法があります:<code>reserve</code>関数です:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-d data-lang=d><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>[]</span> <span class=n>ints</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ints</span><span class=o>.</span><span class=na>reserve</span><span class=o>(</span><span class=mi>100</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span><span class=o>(</span><span class=n>i</span><span class=o>;</span> <span class=mf>0.</span><span class=o>.</span><span class=na>100</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ints</span> <span class=o>~=</span> <span class=n>i</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>これは少なくとも100の値のメモリをアロケートしますが、返した時点で配列はまだ空(<code>length</code>プロパティは0を返す)
で、デフォルトの初期化はされません。
ループが100個の値のみを追加することを考えると、アロケートが行われないことが保証されます。</p><p><code>new</code>と<code>reserve</code>に加えて、明示的なアロケーションのために<code>GC.malloc</code>を呼ぶことができます。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-d data-lang=d><span class=line><span class=cl><span class=kn>import</span> <span class=nn>core.memory</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=n>intsPtr</span> <span class=o>=</span> <span class=n>GC</span><span class=o>.</span><span class=na>malloc</span><span class=o>(</span><span class=kt>int</span><span class=o>.</span><span class=na>sizeof</span> <span class=o>*</span> <span class=mi>100</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=kd>auto</span> <span class=n>ints</span> <span class=o>=</span> <span class=o>(</span><span class=k>cast</span><span class=o>(</span><span class=kt>int</span><span class=o>*)</span><span class=n>intsPtr</span><span class=o>)[</span><span class=mi>0</span> <span class=o>..</span> <span class=mi>100</span><span class=o>];</span>
</span></span></code></pre></div><p><a href=https://dlang.org/spec/arrays.html#dynamic-arrays>配列リテラル</a>
はたいていアロケートをします。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-d data-lang=d><span class=line><span class=cl><span class=kd>auto</span> <span class=n>ints</span> <span class=o>=</span> <span class=o>[</span><span class=mi>0</span><span class=o>,</span> <span class=mi>1</span><span class=o>,</span> <span class=mi>2</span><span class=o>];</span>
</span></span></code></pre></div><p>これは配列リテラル<code>enum</code>が使われた時にもいえます。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-d data-lang=d><span class=line><span class=cl><span class=kd>enum</span> <span class=n>intsLiteral</span> <span class=o>=</span> <span class=o>[</span><span class=mi>0</span><span class=o>,</span> <span class=mi>1</span><span class=o>,</span> <span class=mi>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl><span class=kd>auto</span> <span class=n>ints1</span> <span class=o>=</span> <span class=n>intsLiteral</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>auto</span> <span class=n>ints2</span> <span class=o>=</span> <span class=n>intsLiteral</span><span class=o>;</span>
</span></span></code></pre></div><p><code>enum</code>はコンパイル時にのみ存在し、メモリアドレスを持ちません。
その名前はその値の同義語です。
それをどこで使っても、その値をその場にコピペするようなものです。
<code>ints1</code>と<code>ints2</code>の両方がそのように宣言されたのとちょうど同じようにアロケーションを引き起こします:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-d data-lang=d><span class=line><span class=cl><span class=kd>auto</span> <span class=n>ints1</span> <span class=o>=</span> <span class=o>[</span><span class=mi>0</span><span class=o>,</span> <span class=mi>1</span><span class=o>,</span> <span class=mi>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl><span class=kd>auto</span> <span class=n>ints2</span> <span class=o>=</span> <span class=o>[</span><span class=mi>0</span><span class=o>,</span> <span class=mi>1</span><span class=o>,</span> <span class=mi>2</span><span class=o>];</span>
</span></span></code></pre></div><p>ターゲットが
<a href=http://dlang.org/spec/arrays.html#static-arrays>静的配列</a>
の場合配列リテラルはアロケートをしません。
また、文字列リテラル(Dで文字列は内部では配列です)はルールの例外です。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-d data-lang=d><span class=line><span class=cl><span class=kt>int</span><span class=o>[</span><span class=mi>3</span><span class=o>]</span> <span class=n>noAlloc1</span> <span class=o>=</span> <span class=o>[</span><span class=mi>0</span><span class=o>,</span> <span class=mi>1</span><span class=o>,</span> <span class=mi>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl><span class=kd>auto</span> <span class=n>noAlloc2</span> <span class=o>=</span> <span class=s>&#34;No Allocation!&#34;</span><span class=o>;</span>
</span></span></code></pre></div><p>連結演算子は常にアロケートをします:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-d data-lang=d><span class=line><span class=cl><span class=kd>auto</span> <span class=n>a1</span> <span class=o>=</span> <span class=o>[</span><span class=mi>0</span><span class=o>,</span> <span class=mi>1</span><span class=o>,</span> <span class=mi>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl><span class=kd>auto</span> <span class=n>a2</span> <span class=o>=</span> <span class=o>[</span><span class=mi>3</span><span class=o>,</span> <span class=mi>4</span><span class=o>,</span> <span class=mi>5</span><span class=o>];</span>
</span></span><span class=line><span class=cl><span class=kd>auto</span> <span class=n>a3</span> <span class=o>=</span> <span class=n>a1</span> <span class=o>~</span> <span class=n>a2</span><span class=o>;</span>
</span></span></code></pre></div><p>Dの<a href=https://dlang.org/spec/hash-map.html>連想配列</a>は独自のアロケーション戦略をもちますが、
あなたはアイテムが追加されたり潜在的に削除されたりした時にアロケートされることを期待します。
連想配列は2つのプロパティ、<code>key</code>と<code>value</code>を公開し、これらは配列をアロケートし、
それぞれのアイテムのコピーで埋めるものです。
イテレーション中にもとの連想配列を変更することを望む場合、
またはそのアイテムがソートされている必要があるとき、
または連想配列と独立して操作されるとき、これらのプロパティはまさにちょうど必要なものです。
そうでなければ、これらはGCに過度の負荷をかける余計なアロケーションです。</p><p>GCが走るとき、スキャンが必要なメモリの合計の量はそのガベージコレクションがどれだけかかるかを決めます。
小さいことは、良いことです。
不必要なアロケーションを避けることは誰にも害を及ぼさず、別の良い軽減戦略です。
そのようなことをするために
<a href=http://dlang.org/spec/hash-map.html#properties>Dの連想配列は3つのプロパティを提供します</a>:
<code>byKey</code>、<code>byValue</code>、<code>byKeyValue</code>です。
これらはそれぞれlazyにイテレートされるforwardレンジを返します。
これらは実際に連想配列のアイテムを参照し、それがイテレート中に変更されないためアロケートを行いません。
レンジの詳細については、Ali Çehreliの
<a href=http://ddili.org/ders/d.en/index.html>Programming in D</a>の
<a href=http://ddili.org/ders/d.en/ranges.html>Ranges</a>と
<a href=http://ddili.org/ders/d.en/ranges_more.html>More Ranges</a>のチャプターを見てください。</p><p>ローカルスタックフレームのポインタを持ち歩く必要があるデリゲートまたは関数リテラルである
<a href=https://dlang.org/spec/function.html#closures>クロージャ</a>は、アロケートをすることがあります。
<a href=http://dlang.org/spec/garbage.html>Garbage Collectionのページ</a>
の最後にリストアップされているアロケートをする言語機能は
<a href=http://dlang.org/spec/expression.html#AssertExpression>アサーション</a>です。
アサーションはDのクラスベースヒエラルキーの一部である<code>AssertError</code>を投げる必要があるため、
それが失敗した時アロケートします(今後の投稿でクラスがGCとどのようにやり取りをするか見ていきます)。</p><p>ところで、Dの標準ライブラリの<a href=https://dlang.org/phobos/index.html>Phobos</a>というのがあります。
かつて、PhobosのほとんどはGCアロケーションをほぼ気にせず実装されており、
それがGCアロケーションが望ましくないシチュエーションでのPhobosの使用を難しくしていました。
しかし、GCの使用についてより保守的にする大きな取り組みが開始されました。
いくつかの関数はlazyなレンジで動作するようになり、
他のものは呼び出し側の提供するバッファをとるように書きなおされ、
さらにいくつかは内部的に不必要なアロケーションを避けるよう再実装されました。
結果として標準ライブラリはよりGCフリーのコードに対して素直になりました
(が、おそらくまだライブラリの隅にまだ改装されていないものがあります
— <a href=https://github.com/dlang/phobos>PRを受け付けています</a>)。</p><p>GCの使用の基礎を見てきたので、このシリーズの次の投稿ではGCをオフにし特定のセクションがGCフリーである
ことを確かめる、言語とコンパイラが提供するツールについて紹介します。</p><p>この記事について協力してくれたGuillaume PiolatとSteven Schveighofferに感謝します。</p></article><footer><h2><a href=/tags/dlang>#dlang</a>
死神を恐れないで - GCについて知る【翻訳】</h2><p><time>2017-04-16</time>
<a href=/tags/dlang>#dlang</a> <a href=/tags/tech>#tech</a> <a href=/tags/translation>#translation</a> <a href=/tags/dlang_gc_series>#dlang_gc_series</a> <a href=/tags/d_blog>#d_blog</a></p><div class=subscribe><a href=/tags/dlang/index.xml><svg width="22" height="18" viewBox="6 8 .5 10" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><desc>Created with Sketch.</desc><defs><path d="M1 21V19c1.1045695.0 2 .8954305 2 2H1zm6 0H5c0-2.209139-1.790861-4-4-4V15c3.3137085.0 6 2.6862915 6 6zm4 0H9c0-4.418278-3.581722-8-8-8V11c5.5228475.0 10 4.4771525 10 10z" id="path-1"/></defs><g id="export" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="cast" transform="translate(-1.000000, -3.000000)"><rect id="placeholder" fill-opacity="0" fill="#fff" x="0" y="0" width="24" height="24"/><mask id="mask-2" fill="#fff"><use xlink:href="#path-1"/></mask><use id="Combined-Shape" fill="#ffa07a" fill-rule="nonzero" xlink:href="#path-1"/></g></g></svg>dlangの記事を購読</a></div></footer><div class=ad-wrapper><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-8443812672116269 data-ad-slot=2914874272 data-ad-format=horizontal data-full-width-responsive=true></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></main><footer class=site><div class=link-wrapper><a href=/ title=tag>Home</a>
<a href=/about title=about>About</a>
<a href=/products title=download>Download</a>
<a href=/tags title=tag>Tag</a>
<a href=/index.xml title=feed>Feed</a>
<a href=/privacy-policy>Privacy Policy</a></div><div class=generated>Generated: 2024-02-20T04:57:11 UTC</div></footer></body></html>